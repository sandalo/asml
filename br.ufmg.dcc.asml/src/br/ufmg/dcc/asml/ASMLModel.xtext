grammar br.ufmg.dcc.asml.ASMLModel with org.eclipse.xtext.common.Terminals
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

generate aSMLModel "http://www.ufmg.br/dcc/asml/ASMLModel"

ASMLModel:
  'architecture' name=ID_ASML '{'
       ('import' importURI=STRING';')?
  		(views += View)*
  		('ignore'((ignore+=STRING)(',')?)*(';'))?
  '}'
;

terminal ID_ASML : ('a'..'z'|'A'..'Z'|'_'|'.') ('a'..'z'|'A'..'Z'|'_'|'-'|'.'|'0'..'9')*;

View: 'view' name=ID_ASML '{'
  		(('attributes' (attributes+=Attribute)(',')?)*(';'))?
  		(components += AbstractComponent)*
  		(restrictions += Restriction)*
  '}'
;

enum Cardinality:
  One="1" | Zero="0" | OneOrMany="1..*" | ZeroOrMany="0..*";


AbstractComponent:   Module | MetaModule | ExternalModule | MetaClass | ExternalClass | Method | ConfigurationElement; 

Attribute: name=ID_ASML ':' value=STRING;

AbstractNameConvetion: STRING | ClassMatching;



enum ExpressionMatchingClause:
	NAME_START_WITH='name start with' | NAME_ENDS_WITH='name ends with' | ANNOTATED_WITH='annotated with'
;

ExpressionMatchingOperator: AND='and' | OR= 'or';

enum ModuleMatchingParamenter:
	PAKCAGE='by package name' | FOLDER='by folder name'  | PAKCAGE_AND_FOLDER='by package and folder name' | EXTERNAL_DEFINITION = 'by external implementation'
;

ModuleMatching:
	(parameter=ModuleMatchingParamenter)
;

ClassMatching:
	(expressionMatching=ExpressionMatchingClause parameter=STRING)
//	(expressionMatchings=ExpressionMatchingClause parameter=STRING (operator=ExpressionMatchingOperator )?)?
;

ConfigurationElement: Configuration | XmlDocument | XmlElement | File ;

File:
  'file' name=ID_ASML '{'
  		('matching' matching=AbstractNameConvetion';')? 
  		('cardinality' cardinality=Cardinality';')? 
  '}'
;

Configuration:
  'configuration' name=ID_ASML '{'
  		('matching' matching=STRING';')? 
  		('cardinality' cardinality=Cardinality';')?
  		(configurationElement += ConfigurationElement)*
  '}'
;

Method:
  'method' name=ID_ASML '{'
  		('matching' matching=STRING';')? 
  		('cardinality' cardinality=Cardinality';')? 
  '}'
;

MetaClass:
  'meta-class' name=ID_ASML ('extends' extends=[MetaClass|QualifiedName])?  '{'
  		('description' description=STRING';')? 
  		('matching:' matching=AbstractNameConvetion';')? 
  		('cardinality' cardinality=Cardinality';')? 
  		(methods += Method)*
  '}'
;

ExternalClass:
  'external-class' name=ID_ASML '{'
  		('description' description=STRING';')? 
  		('type' type=STRING';')? 
  '}'
;


XmlElement:
  'xmlElement' name=ID_ASML '{'
  		('matching' matching=STRING';')? 
  		('cardinality' cardinality=Cardinality';')? 
  '}'
;

XmlDocument:
  'xmlDocument' name=ID_ASML '{'
  		('matching' matching=STRING';')? 
  		('cardinality' cardinality=Cardinality';')? 
  '}'
;


Module:
  'module' name=ID_ASML '{'
   		(('attributes' (attributes+=Attribute)(',')?)*(';'))?
  		('matching' matching=ModuleMatching ';')? 
  		(components += AbstractComponent)*
  		(restrictions += Restriction)*
  '}'
;
 
MetaModule:
  'meta-module' name=ID_ASML '{'
   		(('attributes' (attributes+=Attribute)(',')?)*(';'))?
  		('matching' matching=ModuleMatching ';')? 
  		(components += AbstractComponent)*
  		(restrictions += Restriction)*
  '}'
;
 
ExternalModule:
  'external-module' name=ID_ASML '{'
   		(('attributes' (attributes+=Attribute)(',')?)*(';'))?
  		('matching' matching=ModuleMatching ';')? 
  		(components += AbstractComponent)*
  		(restrictions += Restriction)*
  '}'
;
 
QualifiedName:
  ID_ASML ('.' ID_ASML)*
; 
 
enum GroupClause:
	NULL = 'null' | ONLY='only' | ANY='any' | NO_ONE='no one'
;

enum PermissionClause:
	NULL='null' | MUST='must' | CAN='can' | CANNOT ='cannot'
;

enum RelactionType:
	ACCESS='access' | DECLARE='declare' | HANDLE='handle' | EXTEND='extend' | IMPLEMENT = 'implement' | CREATE='create' | THROW='throw' | USEANOTATION='use annotation'
	| DEPEND = 'depend' | REQUIRES='requires'
;


Restriction:
	'restriction' '{' (groupClause=GroupClause)? componentA+=([AbstractComponent|QualifiedName])*  (permissionClause=PermissionClause)? relactionType=RelactionType componentB=[AbstractComponent|QualifiedName] ('description' description=STRING)?'}' 
; 
// Criar uma tipo para abarcar todos os atributos básicos, e assim evitar redundância e o uso exessivo de instanceof ao utilizar a linguagem programaticamente.